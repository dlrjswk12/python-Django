package ch05_start;
//
public class Orient {}
// 테스트는 두려움을 지루함으로 변화시켜주는 프래그래머의 돌이다. (켄트벡:테스트주도개발)
/*
 * 테스트 코드 만들기 (테스트를 위한 부트스트랩)
 * (1) 접두어 Test로 시작하는 클래스 명을 붙이는 것이 여러 모로 보아 좋다. (물론 접미어로 사용하기도 한다.) 
 * (2) 테스트대상이 되는 컨트롤러 인스턴스를 만들기 위해 @Before 애너테이션 메소드를 이용한다.
 * (3) 테스트 코드에 테스트케이스(메소드)를 만든다. 
 * (4) 테스트 수행 기반이 완료되기 전까지는 더미테스트메소드를 하나 추가하여 미완성임을 표하기 위해(실패를 위해) 남겨놓는다.
 * (5) 또한 구현이 덜 된 테스트의 통과를 막기위해 구현할 게 남았음을 표시하기 위해 예외를 던저놓는 방법을 택한다. 
 * 
 * 
 * 컴포넌트로서의 컨트롤러의 역할 
 * 
 * 클라이언트와 상호작용하며, 각 요청 처리를 제어하고 관리하며 이는 표현계층,비즈니스계층 패턴 모두에 사용된다.
 * 
 * 일반적인 컨트롤러의 임무에 대한 요구사항 - 해결 코딩 예 
 * 
 * (1) 요청 수락 - public Response processRequest(Request request)
 * (2) 적절한 요청 핸들러의 선택 - this.requestHandlers.get(request.getName())
 * (3) 핸들러가 관련 비즈니스로직을 수행할 수 있도록 요청 라우팅(routing) - response = getRequestHandler(request).process(request);
 * (4) 오류나 예외 처리를 위한 최상위 핸들러 제공  - ErrorResponse 클래스 
 * 
 * 일반적으로 사용될 필수 객체 4개 
 * 
 * Request, RequestHandler, Response, Controller
 * 요구 -> 요구 핸들링 -> 응답  
 * 
 * 
 * 단위테스트의 핵심 - 한 번에 한 객체씩 테스트 하는 것 
 * 단위테스트를 위해 작성할 2종류의 객체  - (1) 테스트 대상 도메인 객체   (2) 대상객체와 상호작용할 테스트 객체 
 * (*) 도메인객체 - 단위 테스트에서의 도메인 객체란 실제 어플리케이션 범주에 포함된 객체들을 뜻한다. 이는 어플리케이션을 테스트
 * 하기 위한 테스트 객체와는 구분된다. 즉, 테스트 대상이 되는 모든 객체를 도메인 객채로 본다. 
 * 
 * 즉, 예제 코드에서 TestDefaultController 는 도메인객체인 DefaultController 객체를 테스트하는 테스트 객체 이다. 
 * 
 * DefaultController 인스턴스  ~ 도메인 객체 
 * TestDefaultController 인스턴스 ~ 테스트 객체 
 * 
 * 
 * 한번에 한 객체씩 테스트 하는것 - 단위테스트 
 * 만약에 한 번에 두 개 이상의 객체를 테스트 한다면 그 중 한 객체만 수정되어도 서로 간에 어떤 영향을 줄지 예측이 어렵다.
 * 만약 테스트 대상 객체가 다른 복잡한 객체와 상호작용한다면, 복잡한 객체 대신 얘측 가능한 테스트용 도우미 객체들로 감싸서
 * 테스트 해야한다.  
 * 
 * 도메인 객체 간의 연동 테스트를 위해선 '통합 테스트' 라는 또 다른 종류의 소프트웨어 테스트가 있다. 
 * 
 * 하나의 테스트 메소드 안에서 두 개 이상의 테스트를 하지 말자~~~ 그리고 테스트 사이에서 픽스처(fixture)를 공유하자
 * 이를 위해 만들어진 애너테이션 - @Before, @After, @BeforeClass, @AfterClass 
 * 
 * (*) 실패할 가능성이 있는 모든 것을 테스트 해야 한다. 
 * 그래서 예외 상황을 시물레이션하기를 한다. 
 * 
 * (*) 테스트를 통해 진전된 코드로 개선할 수 있다. 
 * 
 * 
 * 
 * (*) 경우에 따라선 테스트클래스와 도메인 클래스는 같은 패키지를 공유하되, 물리적으로 다른 디렉터리 구조를 사용하는것이
 * 좋다. protected 메소드에 접근하려면 테스트와 도메인 클래스는 같은 클래스에 두어야 한다. 그리고 파일을 관리하는 측변에서
 * 테스트와 도메인 클래스를 구분 해 두는 것이 편리할 것이다. 
 * 
 * 
 * */

/**
 * 개별 단위 테스트가 끝났다면, 다음은 통합테스트 -> 기능테스트 -> 스트레스,부하 테스트 -> 인수테스트 순으로 고려되어야 한다.
 * 
 *[통합테스트] 는 여러 컴포넌트 간의 상호작용을 테스트 하는 것이다. 상호작용별로 구분하여 설명한다.
 * 
 * (1) 객체 간 상호작용 - 테스트는 객체들을 생성하고, 객체에 정의된 메소드들을 호출한다.
 * (2) 서비스 간 상호작용 - 테스트는 서블릿이나 EJB 컨테이너가 애플리케이션을 구동하는 과정에서 실행된다. 서블릿이나 EJB컨테이너
 * 는 데이터베이스에 연결되거나, 필요 여타의 외부 자원이나 기기를 사용할 수도 있다.
 * (3) 서브 시스템 간 상호작용 - 계층적 애플리케이션은 표현 계층을 담당하는 프론트엔드와 비즈니스 로직을 실행하는 백엔드로 구성되기도
 * 한다. 이 경우 테스트는 프론트엔드로 부터 요청이 잘 전달되어 백엔드가 적절히 응답하는지를 검사할 수 있다.
 * 
 * 
 *[기능테스트] 는 공개된 API의 가장 바깥쪽에 해당하는 코드를 검사한다. 즉, 애플리케이션을 유스케이스 단위로 테스트 한다.
 * 
 * 프레임워크를 이용하는 애플리케이션 - 프레임워크의 기능 테스트는 최종사용자나 서비스 제공자 관점에서 프레임워크 API테스트에 집중한다.
 * GUI를 포함하는 애플리케이션 - GUI기능 테스트는 모든 기능을 사용할 수 있고 또 기대한 대로 동작하는지 검증한다.
 * 테스트에서 GUI를 직접 제어하는데, 그 과정에서 연관된 다른 컴포넌트나 백엔드 시스템을 호출한다.
 * 서브시스템들로 구성된 애플리케이션 - 계층적 시스템의 각 계층은 전체 시스템을 역할별로 세분화한 것이다.
 * 표현 서브 시스템. 데이터 서브 시스템. 비지니스 로직 서브 시스템. 등으로 나눌 수 있다.
 * 계층화는 유연성을 제공함으로써 서로 다른 프론트엔드를 통해서도 같은 백엔드에 접근할 수 있다. 각 계층은 다른 계층들에서
 * 사용할 수 있도록 API를 제공하는데, 이것이 바로 기능 테스트가 검사하는 대상이다. 
 * 
 * [스트레스,로드 테스트] 
 * JMeter 와 같은 도구를 이용하여 많은 동시다발적인 상황을 연출하여 잘 견딜 수 있는지 스트레스를 주어 얼마나 많이 요청을 
 * 처리하는 지를 검사한다. 응답의 정확성 테스트도 병행되어야 할 것이다. 물론 테스트 환경은 운용 환경과 유사해야 한다. 
 * (*) 프로파일링 - 툴의 프로파일러는 최적화가 필요한 병목 지점을 찾아준다. 그러면 우리는 병목지점이 어디인지 명확히 증명할 
 * 수 있어야 하고, 우리 코드가 그 병목을 제거했음을 증명해야 한다.
 * 단위테스트의 @Test(timeout=5000) 와 같이 이용하여, 시간 기준 테스트를 서술하므로써 성능테스트로 변신 시킬 수 있다. 
 * 
 * [인수테스트] 
 * 애플리케이션이 고객과 이해관계자가 정의한 모든 목적에 부합되는 지 확인하는 테스트 이다. 
 * 인수 테스트는 모든 종류의 테스트를 포함한다. 기능테스트, 성능테스트, 사용성과룩엔필, 개발자가 수행한 테스트 일부포함 가능
 * 다만, 이는 고객이나 품질보증팀에서 진행한다.
 * 
 * 
 * [단위 테스트의 3가지 멋: 논리, 통합, 기능]
 * 논리단위테스트 - 하나의 메소드에 집중한 테스트로 목 객체나 스텁을 이용해 테스트 메소드의 경계를 제어할 수 있다.
 * 통합단위테스트 - 실제 운영환경이나 그 일부에서 컴포넌트 간 연동에 치중한 테스트. 예를 들면 데이터베이스를 효과적으로 호출하는
 * 가 테스트
 * 기능단위테스트 - 자극 반응을 확인하기 위해 통합 단위 테스트의 경계를 확장한 테스트, 예를 들어 인증된 클라이언트만 접근 가능한
 * 보안 웹 페이지를 가진 웹 애플리케이션을 가정하면, 만약 로그인 하지 않은 채 보안 페이지에 접근하려할 때, 클라이언트를 로그인 
 * 페이지로 돌려보내야 한다. 이 상황을 검사하려면, 기능 단위 테스트는 이 페이지에 접속하려는 http요청을 보내고, 응답으로 
 * 재전송 코드(http 상태코드 302)가 오는지 확인하는 방법
 * 
 */

